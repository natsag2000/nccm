/*! For license information please see vue-image-lightbox.min.js.LICENSE.txt */
!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e() : typeof define === 'function' && define.amd ? define([], e) : typeof exports === 'object' ? exports.Lightbox = e() : t.Lightbox = e() }(window, function () { return (function (t) { const e = {}; function n (i) { if (e[i]) { return e[i].exports } const s = e[i] = { i, l: !1, exports: {} }; return t[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports } return n.m = t, n.c = e, n.d = function (t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(t, '__esModule', { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) { return t } if (4 & e && typeof t === 'object' && t && t.__esModule) { return t } const i = Object.create(null); if (n.r(i), Object.defineProperty(i, 'default', { enumerable: !0, value: t }), 2 & e && typeof t !== 'string') { for (const s in t) { n.d(i, s, function (e) { return t[e] }.bind(null, s)) } } return i }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, 'a', e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = '/', n(n.s = 3) }([function (t, e, n) {}, function (t, e, n) { let i; !(function (s, o, r, a) { 'use strict'; let c; const u = ['', 'webkit', 'Moz', 'MS', 'ms', 'o']; const l = o.createElement('div'); const h = Math.round; const p = Math.abs; const d = Date.now; function f (t, e, n) { return setTimeout(x(t, n), e) } function v (t, e, n) { return !!Array.isArray(t) && (m(t, n[e], n), !0) } function m (t, e, n) { let i; if (t) { if (t.forEach) { t.forEach(e, n) } else if (void 0 !== t.length) { for (i = 0; i < t.length;) { e.call(n, t[i], i, t), i++ } } else { for (i in t) { t.hasOwnProperty(i) && e.call(n, t[i], i, t) } } } } function g (t, e, n) { const i = 'DEPRECATED METHOD: ' + e + '\n' + n + ' AT \n'; return function () { const e = new Error('get-stack-trace'); const n = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace'; const o = s.console && (s.console.warn || s.console.log); return o && o.call(s.console, i, n), t.apply(this, arguments) } }c = typeof Object.assign !== 'function' ? function (t) { if (t == null) { throw new TypeError('Cannot convert undefined or null to object') } for (var e = Object(t), n = 1; n < arguments.length; n++) { const i = arguments[n]; if (i != null) { for (const s in i) { i.hasOwnProperty(s) && (e[s] = i[s]) } } } return e } : Object.assign; const y = g(function (t, e, n) { for (let i = Object.keys(e), s = 0; s < i.length;) { (!n || n && void 0 === t[i[s]]) && (t[i[s]] = e[i[s]]), s++ } return t }, 'extend', 'Use `assign`.'); const T = g(function (t, e) { return y(t, e, !0) }, 'merge', 'Use `assign`.'); function b (t, e, n) { let i; const s = e.prototype; (i = t.prototype = Object.create(s)).constructor = t, i._super = s, n && c(i, n) } function x (t, e) { return function () { return t.apply(e, arguments) } } function _ (t, e) { return typeof t === 'function' ? t.apply(e && e[0] || void 0, e) : t } function E (t, e) { return void 0 === t ? e : t } function w (t, e, n) { m(L(e), function (e) { t.addEventListener(e, n, !1) }) } function I (t, e, n) { m(L(e), function (e) { t.removeEventListener(e, n, !1) }) } function C (t, e) { for (;t;) { if (t == e) { return !0 } t = t.parentNode } return !1 } function S (t, e) { return t.includes(e) } function L (t) { return t.trim().split(/\s+/g) } function P (t, e, n) { if (t.indexOf && !n) { return t.indexOf(e) } for (let i = 0; i < t.length;) { if (n && t[i][n] == e || !n && t[i] === e) { return i } i++ } return -1 } function A (t) { return Array.prototype.slice.call(t, 0) } function O (t, e, n) { for (var i = [], s = [], o = 0; o < t.length;) { const r = e ? t[o][e] : t[o]; P(s, r) < 0 && i.push(t[o]), s[o] = r, o++ } return n && (i = e ? i.sort(function (t, n) { return t[e] > n[e] }) : i.sort()), i } function M (t, e) { for (var n, i, s = e[0].toUpperCase() + e.slice(1), o = 0; o < u.length;) { if ((i = (n = u[o]) ? n + s : e) in t) { return i } o++ } } let N = 1; function z (t) { const e = t.ownerDocument || t; return e.defaultView || e.parentWindow || s } const D = 'ontouchstart' in s; const R = void 0 !== M(s, 'PointerEvent'); const k = D && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent); const $ = ['x', 'y']; const B = ['clientX', 'clientY']; function X (t, e) { const n = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { _(t.options.enable, [t]) && n.handler(e) }, this.init() } function Y (t, e, n) { const i = n.pointers.length; const s = n.changedPointers.length; const o = 1 & e && i - s == 0; const r = 12 & e && i - s == 0; n.isFirst = !!o, n.isFinal = !!r, o && (t.session = {}), n.eventType = e, (function (t, e) { const n = t.session; const i = e.pointers; const s = i.length; n.firstInput || (n.firstInput = F(e)); s > 1 && !n.firstMultiple ? n.firstMultiple = F(e) : s === 1 && (n.firstMultiple = !1); const o = n.firstInput; const r = n.firstMultiple; const a = r ? r.center : o.center; const c = e.center = q(i); e.timeStamp = d(), e.deltaTime = e.timeStamp - o.timeStamp, e.angle = H(a, c), e.distance = V(a, c), (function (t, e) { const n = e.center; let i = t.offsetDelta || {}; let s = t.prevDelta || {}; const o = t.prevInput || {}; e.eventType !== 1 && o.eventType !== 4 || (s = t.prevDelta = { x: o.deltaX || 0, y: o.deltaY || 0 }, i = t.offsetDelta = { x: n.x, y: n.y }); e.deltaX = s.x + (n.x - i.x), e.deltaY = s.y + (n.y - i.y) }(n, e)), e.offsetDirection = W(e.deltaX, e.deltaY); const u = j(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = u.x, e.overallVelocityY = u.y, e.overallVelocity = p(u.x) > p(u.y) ? u.x : u.y, e.scale = r ? (l = r.pointers, h = i, V(h[0], h[1], B) / V(l[0], l[1], B)) : 1, e.rotation = r ? (function (t, e) { return H(e[1], e[0], B) + H(t[1], t[0], B) }(r.pointers, i)) : 0, e.maxPointers = n.prevInput ? e.pointers.length > n.prevInput.maxPointers ? e.pointers.length : n.prevInput.maxPointers : e.pointers.length, (function (t, e) { let n; let i; let s; let o; const r = t.lastInterval || e; const a = e.timeStamp - r.timeStamp; if (e.eventType != 8 && (a > 25 || void 0 === r.velocity)) { const c = e.deltaX - r.deltaX; const u = e.deltaY - r.deltaY; const l = j(a, c, u); i = l.x, s = l.y, n = p(l.x) > p(l.y) ? l.x : l.y, o = W(c, u), t.lastInterval = e } else { n = r.velocity, i = r.velocityX, s = r.velocityY, o = r.direction }e.velocity = n, e.velocityX = i, e.velocityY = s, e.direction = o }(n, e)); let l, h; let f = t.element; C(e.srcEvent.target, f) && (f = e.srcEvent.target); e.target = f }(t, n)), t.emit('hammer.input', n), t.recognize(n), t.session.prevInput = n } function F (t) { for (var e = [], n = 0; n < t.pointers.length;) { e[n] = { clientX: h(t.pointers[n].clientX), clientY: h(t.pointers[n].clientY) }, n++ } return { timeStamp: d(), pointers: e, center: q(e), deltaX: t.deltaX, deltaY: t.deltaY } } function q (t) { const e = t.length; if (e === 1) { return { x: h(t[0].clientX), y: h(t[0].clientY) } } for (var n = 0, i = 0, s = 0; s < e;) { n += t[s].clientX, i += t[s].clientY, s++ } return { x: h(n / e), y: h(i / e) } } function j (t, e, n) { return { x: e / t || 0, y: n / t || 0 } } function W (t, e) { return t === e ? 1 : p(t) >= p(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 } function V (t, e, n) { n || (n = $); const i = e[n[0]] - t[n[0]]; const s = e[n[1]] - t[n[1]]; return Math.sqrt(i * i + s * s) } function H (t, e, n) { n || (n = $); const i = e[n[0]] - t[n[0]]; const s = e[n[1]] - t[n[1]]; return 180 * Math.atan2(s, i) / Math.PI }X.prototype = { handler () {}, init () { this.evEl && w(this.element, this.evEl, this.domHandler), this.evTarget && w(this.target, this.evTarget, this.domHandler), this.evWin && w(z(this.element), this.evWin, this.domHandler) }, destroy () { this.evEl && I(this.element, this.evEl, this.domHandler), this.evTarget && I(this.target, this.evTarget, this.domHandler), this.evWin && I(z(this.element), this.evWin, this.domHandler) } }; const U = { mousedown: 1, mousemove: 2, mouseup: 4 }; function G () { this.evEl = 'mousedown', this.evWin = 'mousemove mouseup', this.pressed = !1, X.apply(this, arguments) }b(G, X, { handler (t) { let e = U[t.type]; 1 & e && t.button === 0 && (this.pressed = !0), 2 & e && t.which !== 1 && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: 'mouse', srcEvent: t })) } }); const K = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }; const Z = { 2: 'touch', 3: 'pen', 4: 'mouse', 5: 'kinect' }; let J = 'pointerdown'; let Q = 'pointermove pointerup pointercancel'; function tt () { this.evEl = J, this.evWin = Q, X.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] }s.MSPointerEvent && !s.PointerEvent && (J = 'MSPointerDown', Q = 'MSPointerMove MSPointerUp MSPointerCancel'), b(tt, X, { handler (t) { const e = this.store; let n = !1; const i = t.type.toLowerCase().replace('ms', ''); const s = K[i]; const o = Z[t.pointerType] || t.pointerType; const r = o == 'touch'; let a = P(e, t.pointerId, 'pointerId'); 1 & s && (t.button === 0 || r) ? a < 0 && (e.push(t), a = e.length - 1) : 12 & s && (n = !0), a < 0 || (e[a] = t, this.callback(this.manager, s, { pointers: e, changedPointers: [t], pointerType: o, srcEvent: t }), n && e.splice(a, 1)) } }); const et = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function nt () { this.evTarget = 'touchstart', this.evWin = 'touchstart touchmove touchend touchcancel', this.started = !1, X.apply(this, arguments) } function it (t, e) { let n = A(t.touches); const i = A(t.changedTouches); return 12 & e && (n = O(n.concat(i), 'identifier', !0)), [n, i] }b(nt, X, { handler (t) { const e = et[t.type]; if (e === 1 && (this.started = !0), this.started) { const n = it.call(this, t, e); 12 & e && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: 'touch', srcEvent: t }) } } }); const st = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function ot () { this.evTarget = 'touchstart touchmove touchend touchcancel', this.targetIds = {}, X.apply(this, arguments) } function rt (t, e) { const n = A(t.touches); const i = this.targetIds; if (3 & e && n.length === 1) { return i[n[0].identifier] = !0, [n, n] } let s; let o; const r = A(t.changedTouches); const a = []; const c = this.target; if (o = n.filter(function (t) { return C(t.target, c) }), e === 1) { for (s = 0; s < o.length;) { i[o[s].identifier] = !0, s++ } } for (s = 0; s < r.length;) { i[r[s].identifier] && a.push(r[s]), 12 & e && delete i[r[s].identifier], s++ } return a.length ? [O(o.concat(a), 'identifier', !0), a] : void 0 }b(ot, X, { handler (t) { const e = st[t.type]; const n = rt.call(this, t, e); n && this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: 'touch', srcEvent: t }) } }); function at () { X.apply(this, arguments); const t = x(this.handler, this); this.touch = new ot(this.manager, t), this.mouse = new G(this.manager, t), this.primaryTouch = null, this.lastTouches = [] } function ct (t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, ut.call(this, e)) : 12 & t && ut.call(this, e) } function ut (t) { const e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { const n = { x: e.clientX, y: e.clientY }; this.lastTouches.push(n); const i = this.lastTouches; setTimeout(function () { const t = i.indexOf(n); t > -1 && i.splice(t, 1) }, 2500) } } function lt (t) { for (let e = t.srcEvent.clientX, n = t.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) { const s = this.lastTouches[i]; const o = Math.abs(e - s.x); const r = Math.abs(n - s.y); if (o <= 25 && r <= 25) { return !0 } } return !1 }b(at, X, { handler (t, e, n) { const i = n.pointerType == 'touch'; const s = n.pointerType == 'mouse'; if (!(s && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) { if (i) { ct.call(this, e, n) } else if (s && lt.call(this, n)) { return } this.callback(t, e, n) } }, destroy () { this.touch.destroy(), this.mouse.destroy() } }); const ht = M(l.style, 'touchAction'); const pt = void 0 !== ht; const dt = (function () { if (!pt) { return !1 } const t = {}; const e = s.CSS && s.CSS.supports; return ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (n) { t[n] = !e || s.CSS.supports('touch-action', n) }), t }()); function ft (t, e) { this.manager = t, this.set(e) }ft.prototype = { set (t) { t == 'compute' && (t = this.compute()), pt && this.manager.element.style && dt[t] && (this.manager.element.style[ht] = t), this.actions = t.toLowerCase().trim() }, update () { this.set(this.manager.options.touchAction) }, compute () { let t = []; return m(this.manager.recognizers, function (e) { _(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) }), (function (t) { if (S(t, 'none')) { return 'none' } const e = S(t, 'pan-x'); const n = S(t, 'pan-y'); if (e && n) { return 'none' } if (e || n) { return e ? 'pan-x' : 'pan-y' } if (S(t, 'manipulation')) { return 'manipulation' } return 'auto' }(t.join(' '))) }, preventDefaults (t) { const e = t.srcEvent; const n = t.offsetDirection; if (this.manager.session.prevented) { e.preventDefault() } else { const i = this.actions; const s = S(i, 'none') && !dt.none; const o = S(i, 'pan-y') && !dt['pan-y']; const r = S(i, 'pan-x') && !dt['pan-x']; if (s) { const a = t.pointers.length === 1; const c = t.distance < 2; const u = t.deltaTime < 250; if (a && c && u) { return } } if (!r || !o) { return s || o && 6 & n || r && 24 & n ? this.preventSrc(e) : void 0 } } }, preventSrc (t) { this.manager.session.prevented = !0, t.preventDefault() } }; function vt (t) { this.options = c({}, this.defaults, t || {}), this.id = N++, this.manager = null, this.options.enable = E(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function mt (t) { return 16 & t ? 'cancel' : 8 & t ? 'end' : 4 & t ? 'move' : 2 & t ? 'start' : '' } function gt (t) { return t == 16 ? 'down' : t == 8 ? 'up' : t == 2 ? 'left' : t == 4 ? 'right' : '' } function yt (t, e) { const n = e.manager; return n ? n.get(t) : t } function Tt () { vt.apply(this, arguments) } function bt () { Tt.apply(this, arguments), this.pX = null, this.pY = null } function xt () { Tt.apply(this, arguments) } function _t () { vt.apply(this, arguments), this._timer = null, this._input = null } function Et () { Tt.apply(this, arguments) } function wt () { Tt.apply(this, arguments) } function It () { vt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Ct (t, e) { return (e = e || {}).recognizers = E(e.recognizers, Ct.defaults.preset), new St(t, e) }vt.prototype = { defaults: {}, set (t) { return c(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith (t) { if (v(t, 'recognizeWith', this)) { return this } const e = this.simultaneous; return e[(t = yt(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith (t) { return v(t, 'dropRecognizeWith', this) || (t = yt(t, this), delete this.simultaneous[t.id]), this }, requireFailure (t) { if (v(t, 'requireFailure', this)) { return this } const e = this.requireFail; return P(e, t = yt(t, this)) === -1 && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure (t) { if (v(t, 'dropRequireFailure', this)) { return this } t = yt(t, this); const e = P(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures () { return this.requireFail.length > 0 }, canRecognizeWith (t) { return !!this.simultaneous[t.id] }, emit (t) { const e = this; const n = this.state; function i (n) { e.manager.emit(n, t) }n < 8 && i(e.options.event + mt(n)), i(e.options.event), t.additionalEvent && i(t.additionalEvent), n >= 8 && i(e.options.event + mt(n)) }, tryEmit (t) { if (this.canEmit()) { return this.emit(t) } this.state = 32 }, canEmit () { for (let t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) { return !1 } t++ } return !0 }, recognize (t) { const e = c({}, t); if (!_(this.options.enable, [this, e])) { return this.reset(), void (this.state = 32) } 56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process (t) {}, getTouchAction () {}, reset () {} }, b(Tt, vt, { defaults: { pointers: 1 }, attrTest (t) { const e = this.options.pointers; return e === 0 || t.pointers.length === e }, process (t) { const e = this.state; const n = t.eventType; const i = 6 & e; const s = this.attrTest(t); return i && (8 & n || !s) ? 16 | e : i || s ? 4 & n ? 8 | e : 2 & e ? 4 | e : 2 : 32 } }), b(bt, Tt, { defaults: { event: 'pan', threshold: 10, pointers: 1, direction: 30 }, getTouchAction () { const t = this.options.direction; const e = []; return 6 & t && e.push('pan-y'), 24 & t && e.push('pan-x'), e }, directionTest (t) { const e = this.options; let n = !0; let i = t.distance; let s = t.direction; const o = t.deltaX; const r = t.deltaY; return s & e.direction || (6 & e.direction ? (s = o === 0 ? 1 : o < 0 ? 2 : 4, n = o != this.pX, i = Math.abs(t.deltaX)) : (s = r === 0 ? 1 : r < 0 ? 8 : 16, n = r != this.pY, i = Math.abs(t.deltaY))), t.direction = s, n && i > e.threshold && s & e.direction }, attrTest (t) { return Tt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit (t) { this.pX = t.deltaX, this.pY = t.deltaY; const e = gt(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), b(xt, Tt, { defaults: { event: 'pinch', threshold: 0, pointers: 2 }, getTouchAction () { return ['none'] }, attrTest (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit (t) { if (t.scale !== 1) { const e = t.scale < 1 ? 'in' : 'out'; t.additionalEvent = this.options.event + e } this._super.emit.call(this, t) } }), b(_t, vt, { defaults: { event: 'press', pointers: 1, time: 251, threshold: 9 }, getTouchAction () { return ['auto'] }, process (t) { const e = this.options; const n = t.pointers.length === e.pointers; const i = t.distance < e.threshold; const s = t.deltaTime > e.time; if (this._input = t, !i || !n || 12 & t.eventType && !s) { this.reset() } else if (1 & t.eventType) { this.reset(), this._timer = f(function () { this.state = 8, this.tryEmit() }, e.time, this) } else if (4 & t.eventType) { return 8 } return 32 }, reset () { clearTimeout(this._timer) }, emit (t) { this.state === 8 && (t && 4 & t.eventType ? this.manager.emit(this.options.event + 'up', t) : (this._input.timeStamp = d(), this.manager.emit(this.options.event, this._input))) } }), b(Et, Tt, { defaults: { event: 'rotate', threshold: 0, pointers: 2 }, getTouchAction () { return ['none'] }, attrTest (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), b(wt, Tt, { defaults: { event: 'swipe', threshold: 10, velocity: 0.3, direction: 30, pointers: 1 }, getTouchAction () { return bt.prototype.getTouchAction.call(this) }, attrTest (t) { let e; const n = this.options.direction; return 30 & n ? e = t.overallVelocity : 6 & n ? e = t.overallVelocityX : 24 & n && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && n & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && p(e) > this.options.velocity && 4 & t.eventType }, emit (t) { const e = gt(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), b(It, vt, { defaults: { event: 'tap', pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction () { return ['manipulation'] }, process (t) { const e = this.options; const n = t.pointers.length === e.pointers; const i = t.distance < e.threshold; const s = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && this.count === 0) { return this.failTimeout() } if (i && s && n) { if (t.eventType != 4) { return this.failTimeout() } const o = !this.pTime || t.timeStamp - this.pTime < e.interval; const r = !this.pCenter || V(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, r && o ? this.count += 1 : this.count = 1, this._input = t, this.count % e.taps === 0) { return this.hasRequireFailures() ? (this._timer = f(function () { this.state = 8, this.tryEmit() }, e.interval, this), 2) : 8 } } return 32 }, failTimeout () { return this._timer = f(function () { this.state = 32 }, this.options.interval, this), 32 }, reset () { clearTimeout(this._timer) }, emit () { this.state == 8 && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Ct.VERSION = '2.0.7', Ct.defaults = { domEvents: !1, touchAction: 'compute', enable: !0, inputTarget: null, inputClass: null, preset: [[Et, { enable: !1 }], [xt, { enable: !1 }, ['rotate']], [wt, { direction: 6 }], [bt, { direction: 6 }, ['swipe']], [It], [It, { event: 'doubletap', taps: 2 }, ['tap']], [_t]], cssProps: { userSelect: 'none', touchSelect: 'none', touchCallout: 'none', contentZooming: 'none', userDrag: 'none', tapHighlightColor: 'rgba(0,0,0,0)' } }; function St (t, e) { let n; this.options = c({}, Ct.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((n = this).options.inputClass || (R ? tt : k ? ot : D ? at : G))(n, Y), this.touchAction = new ft(this, this.options.touchAction), Lt(this, !0), m(this.options.recognizers, function (t) { const e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }, this) } function Lt (t, e) { let n; const i = t.element; i.style && (m(t.options.cssProps, function (s, o) { n = M(i.style, o), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = s) : i.style[n] = t.oldCssProps[n] || '' }), e || (t.oldCssProps = {})) }St.prototype = { set (t) { return c(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop (t) { this.session.stopped = t ? 2 : 1 }, recognize (t) { const e = this.session; if (!e.stopped) { let n; this.touchAction.preventDefaults(t); const i = this.recognizers; let s = e.curRecognizer; (!s || s && 8 & s.state) && (s = e.curRecognizer = null); for (let o = 0; o < i.length;) { n = i[o], e.stopped === 2 || s && n != s && !n.canRecognizeWith(s) ? n.reset() : n.recognize(t), !s && 14 & n.state && (s = e.curRecognizer = n), o++ } } }, get (t) { if (t instanceof vt) { return t } for (let e = this.recognizers, n = 0; n < e.length; n++) { if (e[n].options.event == t) { return e[n] } } return null }, add (t) { if (v(t, 'add', this)) { return this } const e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove (t) { if (v(t, 'remove', this)) { return this } if (t = this.get(t)) { const e = this.recognizers; const n = P(e, t); n !== -1 && (e.splice(n, 1), this.touchAction.update()) } return this }, on (t, e) { if (void 0 !== t && void 0 !== e) { const n = this.handlers; return m(L(t), function (t) { n[t] = n[t] || [], n[t].push(e) }), this } }, off (t, e) { if (void 0 !== t) { const n = this.handlers; return m(L(t), function (t) { e ? n[t] && n[t].splice(P(n[t], e), 1) : delete n[t] }), this } }, emit (t, e) { this.options.domEvents && (function (t, e) { const n = o.createEvent('Event'); n.initEvent(t, !0, !0), n.gesture = e, e.target.dispatchEvent(n) }(t, e)); const n = this.handlers[t] && this.handlers[t].slice(); if (n && n.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (let i = 0; i < n.length;) { n[i](e), i++ } } }, destroy () { this.element && Lt(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, c(Ct, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: St, Input: X, TouchAction: ft, TouchInput: ot, MouseInput: G, PointerEventInput: tt, TouchMouseInput: at, SingleTouchInput: nt, Recognizer: vt, AttrRecognizer: Tt, Tap: It, Pan: bt, Swipe: wt, Pinch: xt, Rotate: Et, Press: _t, on: w, off: I, each: m, merge: T, extend: y, assign: c, inherit: b, bindFn: x, prefixed: M }), (void 0 !== s ? s : typeof self !== 'undefined' ? self : {}).Hammer = Ct, void 0 === (i = (function () { return Ct }.call(e, n, e, t))) || (t.exports = i) }(window, document)) }, function (t, e, n) { 'use strict'; const i = n(0); n.n(i).a }, function (t, e, n) { 'use strict'; n.r(e); const i = function () { const t = this; const e = t.$createElement; const n = t._self._c || e; return n('div', { on: { click (e) { return e.stopPropagation(), t.closeLightBox(e) } } }, [n('transition', { attrs: { mode: 'out-in', name: 'vue-lb-content-transition' }, on: { afterEnter: t.enableImageTransition, beforeLeave: t.disableImageTransition } }, [t.media && t.media.length > 0 ? n('div', { directives: [{ name: 'show', rawName: 'v-show', value: t.lightBoxOn, expression: 'lightBoxOn' }], ref: 'container', staticClass: 'vue-lb-container' }, [n('div', { staticClass: 'vue-lb-content' }, [n('div', { staticClass: 'vue-lb-header' }, [n('span'), t._v(' '), t.closable ? n('button', { staticClass: 'vue-lb-button-close', attrs: { type: 'button', title: t.closeText } }, [t._t('close', [n('CloseIcon')])], 2) : t._e()]), t._v(' '), n('div', { staticClass: 'vue-lb-figure', on: { click (t) { t.stopPropagation() } } }, [n('transition', { attrs: { mode: 'out-in', name: t.modalImageTransitionName } }, [t.media[t.select].type !== 'video' ? n('img', { directives: [{ name: 'lazy', rawName: 'v-lazy', value: { src: t.media[t.select].src, loading: t.media[t.select].src, error: t.media[t.select].src }, expression: '{\n                src: media[select].src,\n                loading: media[select].src,\n                error: media[select].src,\n              }' }], key: t.media[t.select].src, staticClass: 'vue-lb-modal-image', attrs: { srcset: t.media[t.select].srcset || '', alt: t.media[t.select].caption } }) : n('video', { key: t.media[t.select].sources[0].src, ref: 'video', attrs: { controls: '', width: t.media[t.select].width, height: t.media[t.select].height, autoplay: t.media[t.select].autoplay } }, t._l(t.media[t.select].sources, function (t) { return n('source', { key: t.src, attrs: { src: t.src, type: t.type } }) }), 0)]), t._v(' '), t._t('customCaption', [n('div', { directives: [{ name: 'show', rawName: 'v-show', value: t.showCaption, expression: 'showCaption' }], staticClass: 'vue-lb-info', domProps: { innerHTML: t._s(t.media[t.select].caption) } })]), t._v(' '), n('div', { staticClass: 'vue-lb-footer' }, [n('div', { staticClass: 'vue-lb-footer-info' }), t._v(' '), t.media.length > 1 ? n('div', { staticClass: 'vue-lb-footer-count' }, [t._t('footer', [t._v('\n                ' + t._s(t.select + 1) + ' / ' + t._s(t.media.length) + '\n              ')], { current: t.select + 1, total: t.media.length })], 2) : t._e()])], 2)]), t._v(' '), n('div', { staticClass: 'vue-lb-thumbnail-wrapper' }, [t.showThumbs ? n('div', { staticClass: 'vue-lb-thumbnail' }, [t.media.length > 1 ? n('button', { staticClass: 'vue-lb-thumbnail-arrow vue-lb-thumbnail-left', attrs: { type: 'button', title: t.previousThumbText }, on: { click (e) { return e.stopPropagation(), t.previousImage() } } }, [t._t('previousThumb', [n('LeftArrowIcon')])], 2) : t._e(), t._v(' '), t._l(t.imagesThumb, function (e, i) { return n('div', { directives: [{ name: 'show', rawName: 'v-show', value: i >= t.thumbIndex.begin && i <= t.thumbIndex.end, expression: 'index >= thumbIndex.begin && index <= thumbIndex.end' }, { name: 'lazy', rawName: 'v-lazy:background-image', value: e, expression: 'image', arg: 'background-image' }], key: typeof e.src === 'string' ? '' + e.src + i : i, class: 'vue-lb-modal-thumbnail' + (t.select === i ? '-active' : ''), on: { click (e) { return e.stopPropagation(), t.showImage(i) } } }, [e.type ? t._t('videoIcon', [n('VideoIcon')]) : t._e()], 2) }), t._v(' '), t.media.length > 1 ? n('button', { staticClass: 'vue-lb-thumbnail-arrow vue-lb-thumbnail-right', attrs: { type: 'button', title: t.nextThumbText }, on: { click (e) { return e.stopPropagation(), t.nextImage() } } }, [t._t('nextThumb', [n('RightArrowIcon')])], 2) : t._e()], 2) : t._e()]), t._v(' '), t.media.length > 1 ? n('button', { staticClass: 'vue-lb-arrow vue-lb-left', attrs: { type: 'button', title: t.previousText }, on: { click (e) { return e.stopPropagation(), t.previousImage() } } }, [t._t('previous', [n('LeftArrowIcon')])], 2) : t._e(), t._v(' '), t.media.length > 1 ? n('button', { staticClass: 'vue-lb-arrow vue-lb-right', attrs: { type: 'button', title: t.nextText }, on: { click (e) { return e.stopPropagation(), t.nextImage() } } }, [t._t('next', [n('RightArrowIcon')])], 2) : t._e()]) : t._e()])], 1) }; i._withStripped = !0; const s = function () { const t = this.$createElement; const e = this._self._c || t; return e('span', [e('svg', { attrs: { fill: 'white', x: '0px', y: '0px', width: '100%', height: '100%', viewBox: '0 0 512 512' } }, [e('path', { attrs: { d: 'M213.7,256L213.7,256L213.7,256L380.9,81.9c4.2-4.3,4.1-11.4-0.2-15.8l-29.9-30.6c-4.3-4.4-11.3-4.5-15.5-0.2L131.1,247.9 c-2.2,2.2-3.2,5.2-3,8.1c-0.1,3,0.9,5.9,3,8.1l204.2,212.7c4.2,4.3,11.2,4.2,15.5-0.2l29.9-30.6c4.3-4.4,4.4-11.5,0.2-15.8 L213.7,256z' } })])]) }; function o (t, e, n, i, s, o, r, a) { let c; const u = typeof t === 'function' ? t.options : t; if (e && (u.render = e, u.staticRenderFns = n, u._compiled = !0), i && (u.functional = !0), o && (u._scopeId = 'data-v-' + o), r ? (c = function (t) { (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (t = __VUE_SSR_CONTEXT__), s && s.call(this, t), t && t._registeredComponents && t._registeredComponents.add(r) }, u._ssrRegister = c) : s && (c = a ? function () { s.call(this, (u.functional ? this.parent : this).$root.$options.shadowRoot) } : s), c) { if (u.functional) { u._injectStyles = c; const l = u.render; u.render = function (t, e) { return c.call(e), l(t, e) } } else { const h = u.beforeCreate; u.beforeCreate = h ? [].concat(h, c) : [c] } } return { exports: t, options: u } }s._withStripped = !0; const r = o({}, s, [], !1, null, null, null); r.options.__file = 'src/components/LeftArrowIcon.vue'; const a = r.exports; const c = function () { const t = this.$createElement; const e = this._self._c || t; return e('span', [e('svg', { attrs: { fill: 'white', x: '0px', y: '0px', width: '100%', height: '100%', viewBox: '0 0 512 512' } }, [e('path', { attrs: { d: 'M298.3,256L298.3,256L298.3,256L131.1,81.9c-4.2-4.3-4.1-11.4,0.2-15.8l29.9-30.6c4.3-4.4,11.3-4.5,15.5-0.2l204.2,212.7 c2.2,2.2,3.2,5.2,3,8.1c0.1,3-0.9,5.9-3,8.1L176.7,476.8c-4.2,4.3-11.2,4.2-15.5-0.2L131.3,446c-4.3-4.4-4.4-11.5-0.2-15.8 L298.3,256z' } })])]) }; c._withStripped = !0; const u = o({}, c, [], !1, null, null, null); u.options.__file = 'src/components/RightArrowIcon.vue'; const l = u.exports; const h = function () { const t = this.$createElement; const e = this._self._c || t; return e('span', [e('svg', { staticStyle: { 'enable-background': 'new 0 0 512 512' }, attrs: { fill: 'white', x: '0px', y: '0px', width: '100%', height: '100%', viewBox: '0 0 512 512' } }, [e('path', { attrs: { d: 'M443.6,387.1L312.4,255.4l131.5-130c5.4-5.4,5.4-14.2,0-19.6l-37.4-37.6c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4 L256,197.8L124.9,68.3c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4L68,105.9c-5.4,5.4-5.4,14.2,0,19.6l131.5,130L68.4,387.1 c-2.6,2.6-4.1,6.1-4.1,9.8c0,3.7,1.4,7.2,4.1,9.8l37.4,37.6c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1L256,313.1l130.7,131.1 c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1l37.4-37.6c2.6-2.6,4.1-6.1,4.1-9.8C447.7,393.2,446.2,389.7,443.6,387.1z' } })])]) }; h._withStripped = !0; const p = o({}, h, [], !1, null, null, null); p.options.__file = 'src/components/CloseIcon.vue'; const d = p.exports; const f = function () { const t = this.$createElement; const e = this._self._c || t; return e('svg', { staticStyle: { 'enable-background': 'new 0 0 271.953 271.953', margin: '12px' }, attrs: { x: '0px', y: '0px', viewBox: '0 0 271.953 271.953', 'xml:space': 'preserve' } }, [e('g', [e('g', [e('path', { staticStyle: { fill: '#fff' }, attrs: { d: 'M135.977,271.953c75.097,0,135.977-60.879,135.977-135.977S211.074,0,135.977,0S0,60.879,0,135.977    S60.879,271.953,135.977,271.953z M250.197,135.977c0,62.979-51.241,114.22-114.22,114.22s-114.22-51.241-114.22-114.22    s51.241-114.22,114.22-114.22S250.197,72.998,250.197,135.977z' } }), this._v(' '), e('path', { staticStyle: { fill: '#fff' }, attrs: { d: 'M112.295,205.031c2.692,1.115,5.434,1.659,8.235,1.659c5.662,0,11.183-2.208,15.344-6.375    l48.93-48.952c8.496-8.496,8.485-22.273-0.011-30.769l-48.957-48.952c-4.161-4.161-9.73-6.375-15.393-6.375    c-2.801,0-5.461,0.544-8.153,1.659c-8.126,3.367-13.255,11.297-13.255,20.097v97.903    C99.034,193.729,104.164,201.664,112.295,205.031z M120.791,88.613v-1.588l48.952,48.952l-48.952,48.952V88.613z' } })])])]) }; f._withStripped = !0; const v = o({}, f, [], !1, null, null, null); v.options.__file = 'src/components/VideoIcon.vue'; let m; const g = v.exports; typeof window !== 'undefined' && (m = n(1)); const y = { components: { LeftArrowIcon: a, RightArrowIcon: l, CloseIcon: d, VideoIcon: g }, props: { media: { type: Array, required: !0 }, disableScroll: { type: Boolean, default: !0 }, showLightBox: { type: Boolean, default: !0 }, closable: { type: Boolean, default: !0 }, startAt: { type: Number, default: 0 }, nThumbs: { type: Number, default: 7 }, showThumbs: { type: Boolean, default: !0 }, autoPlay: { type: Boolean, default: !1 }, autoPlayTime: { type: Number, default: 3e3 }, siteLoading: { type: String, default: '' }, showCaption: { type: Boolean, default: !1 }, lengthToLoadMore: { type: Number, default: 0 }, closeText: { type: String, default: 'Close (Esc)' }, previousText: { type: String, default: 'Previous' }, nextText: { type: String, default: 'Next' }, previousThumbText: { type: String, default: 'Previous' }, nextThumbText: { type: String, default: 'Next' } }, data () { return { select: this.startAt, lightBoxOn: this.showLightBox, timer: null, modalImageTransitionName: 'vue-lb-modal-image-no-transition' } }, computed: { thumbIndex () { const t = Math.floor(this.nThumbs / 2); return this.select >= t && this.select < this.media.length - t ? { begin: this.select - t + (1 - this.nThumbs % 2), end: this.select + t } : this.select < t ? { begin: 0, end: this.nThumbs - 1 } : { begin: this.media.length - this.nThumbs, end: this.media.length - 1 } }, imagesThumb () { const t = this; return this.siteLoading ? this.media.map(function (e) { return { src: e.thumb, type: e.type, loading: t.siteLoading, error: t.siteLoading } }) : this.media.map(function (t) { return { src: t.thumb, type: t.type } }) } }, watch: { lightBoxOn (t) { document != null && this.onToggleLightBox(t) }, select () { this.$emit('onImageChanged', this.select), this.select >= this.media.length - this.lengthToLoadMore - 1 && this.$emit('onLoad'), this.select === this.media.length - 1 && this.$emit('onLastIndex'), this.select === 0 && this.$emit('onFirstIndex'), this.select === this.startAt && this.$emit('onStartIndex') } }, mounted () { const t = this; if (this.autoPlay && (this.timer = setInterval(function () { t.nextImage() }, this.autoPlayTime)), this.onToggleLightBox(this.lightBoxOn), this.$refs.container) { const e = new m(this.$refs.container); e.on('swiperight', function () { t.previousImage() }), e.on('swipeleft', function () { t.nextImage() }) } }, beforeDestroy () { document.removeEventListener('keydown', this.addKeyEvent), this.autoPlay && clearInterval(this.timer) }, methods: { onLightBoxOpen () { this.$emit('onOpened'), this.disableScroll && document.querySelector('html').classList.add('no-scroll'), document.querySelector('body').classList.add('vue-lb-open'), document.addEventListener('keydown', this.addKeyEvent), this.$refs.video && this.$refs.video.autoplay && this.$refs.video.play() }, onLightBoxClose () { this.$emit('onClosed'), this.disableScroll && document.querySelector('html').classList.remove('no-scroll'), document.querySelector('body').classList.remove('vue-lb-open'), document.removeEventListener('keydown', this.addKeyEvent), this.$refs.video && (this.$refs.video.pause(), this.$refs.video.currentTime = 0) }, onToggleLightBox (t) { t ? this.onLightBoxOpen() : this.onLightBoxClose() }, showImage (t) { this.$set(this, 'select', t), this.$set(this, 'lightBoxOn', !0) }, addKeyEvent (t) { t.keyCode === 37 && this.previousImage(), t.keyCode === 39 && this.nextImage(), t.keyCode === 27 && this.closeLightBox() }, closeLightBox () { this.closable && this.$set(this, 'lightBoxOn', !1) }, nextImage () { this.$set(this, 'select', (this.select + 1) % this.media.length) }, previousImage () { this.$set(this, 'select', (this.select + this.media.length - 1) % this.media.length) }, enableImageTransition () { this.$set(this, 'modalImageTransitionName', 'vue-lb-modal-image-transition') }, disableImageTransition () { this.$set(this, 'modalImageTransitionName', 'vue-lb-modal-image-no-transition') } } }; const T = (n(2), o(y, i, [], !1, null, null, null)); T.options.__file = 'src/components/LightBox.vue'; e.default = T.exports }])) }))
// # sourceMappingURL=vue-image-lightbox.min.js.map
